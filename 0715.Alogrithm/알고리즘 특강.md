## 알고리즘 특강

## 1. 자료구조 

1. 선형그래프
   - 선형리스트
   - 연결리스트
     - 스택
     - 일반큐/원형큐
2. 비선형그래프
   - 트리 (이진탐색트리)
   - 그래프 (무방향그 래프)

## 2. 알고리즘

1. 재귀알고리즘
2. 정렬 (Sorting) : 선택정렬
3. 검색 : 순차검색, 이진검색



<hr>


## 자료구조



### 1.선형리스트


선형리스트 : 물리적으로 논리적으로도 붙어있다. 

- 삽입 : 맨뒤 빈칸추가
- 삭제 : 빈칸있으면 안되서 삭제하면 다 떙김



### 2.연결리스트


단순연결리스트 : 논리적으론 이어져있지만, 물리적으론 떨어져있음 

데이터와 함께 링크가 하나로 합쳐서 ''노드"로 구성

- 삽입 : 맨앞에 삽입, 맨뒤에 추가, 가운데 삽입

- 삭제 : 헤드삭제, 헤드가 아닌거 삭제

- 검색 : 헤드부터 노드검색

  

### 3.스택

사이즈제한이 있음, 한쪽이 막혀있음

- push : 데이터삽입 (데이터지정해서 넣음)
- pop : 데이터추출 (데이터를 지정할 수 없고 무조건 젤 위에 있는거 나옴)

push하기 전엔 꽉 찼는지 확인해야하고, pop하기 전엔 스택이 비었는지(top이 -1인지) 확인 



### 4.큐

양쪽이 뚤려있는 구조, 반면에 스택은 한쪽이 막혀있음

- enQueue(인큐) : 큐에 데이터 삽입
- deQueu(디큐) : 데이터 추출
- front(머리) : 저장된 데이터 중에 첫번쨰 데이터
- rear(꼬리) :  저장된 데이터 중에 마지막 데이터



### 5.트리

이진트리 : 모든 노드의 자식이 최대2개인 트리

완전이진트리 : 모든 노드의 자식이 2개인 트리 

이진트리 순회 : 이진트리의 노드전체를 한번씩 방문하는 것

- 전위 : 루트->왼쪽->오른쪽 
- 중위 : 왼쪽->루트->오른쪽
- 후위 : 왼쪽->오른쪽->루트

이진탐색 트리 : 데이터크기를 기준으로 일정형태로 구성

- 1-왼쪽 서브트리는 루트노드보다 모두 작은값을 가진다
- 2-오른쪽 서브트리는 루트노드보다 모두 큰 값을 가진다
- 3-각 서브트리도 1,2특징을 갖는다.
- 4-모든 노드값은 중복되지 않는다. 즉 중복된 값은 이진탐색트리에 저장할 수 없다. 

이진탐색 트리에서 검색 

if 현재작업노드의 데이터 == 찾을데이터 : 탐색종료

elif 현재작업노드의 데이터 < 찾을데이터 : 왼쪽 서브트리탐색

else 왼쪽 서브트리탐색



### 6.그래프

여러노드가 서로 연결된 자료구조

- 무방향그래프 
- 방향그래프
- 가중치그래프 : 간선마다 가중치가 다르게 부여된 그래프

깊이우선탐색 

넓이우선탐색

<hr>



## 자료구조

### 1. 재귀호출(Recursive)

자기자신을 다시 호출하는 것 

일반적인 프로그램에서는 무한반복을 마치고 되돌아가는 조건을 함께 사용 

### 2.정렬(Sort)

선택정렬 : 여러 데이터 중에서 가장 작은 값을 뽑는 작동반복하여 값 정렬

```
def selectionSort(arr):
	n=len(arr)
	for i in range(i+1,n):
		if arr[minIdx] > arr[k]:
			minIdx = k
		arr[i], arr[minIdx] = arr[minIdx],arr[i]
    return arr

dataArray=[50,60,105,120,150,160,162,168,177,178]
print("정렬 전",dataArray)

dataArray = selectionSort(dataArray)
print("정렬 후",dataArray)
```



### 3.이진검색(binary Search)

전체를 **반 짤라** 내서 **한쪽을 버리는** 방식으로 검색 (정렬이 되어 있다는 전제)

시작과 끝이 교차해버리면 찾을 의미가 없다. 못찾음 

```
def binarySearch(arra,fdata):
	pos = -1 
	start=0
	end=len(arr)-1
	
	while(start<=end):
		mid=(start+end)//2
		
		if fdata ==arr[mid]: #찾을때
			return mid
		elif fdata > arra[mid]: #오른쪽내용에서 검색
			start = mind +1
		else:
			end=min-1 #왼쪽내용에서검색
	
	return pos
	
	
dataArray=[50,60,105,120,150,160,162,168,177,178]
findata = 162 #할머니키

print("배열",dataArray)
position = binarySearch(dataArray,findata)
if position == -1:
	print("못찾음")
else:
	print(findata,"의 위치",position)
```

